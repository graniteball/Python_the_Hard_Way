Alan Gilbert:
	Hey, you there?
Scott Ziegler:
	yeah whats up
Alan Gilbert:
	I have a Python question for you
	I am looking at test_client.py
Scott Ziegler:
	shoot
Alan Gilbert:
	the syntax on one of the request calls is return requests.post(url, data=data)

	why not just return requests.post(url, data)

	why the data=data ?
Scott Ziegler:
	well...
	the requests.post method signature can take a lot of parameters
	but there is one special one named data that is what gets POSTed...
	you hand it a dictionary to make a POST out of...
	anyhow
	in my function there, my local variable happens to ALSO be called data
	now, what you suggested WOULD in fact be correct if and only if the 'data' param of the requests.post method is the second parameter
	(I don't happen to recall off the top if it is or isn't BUT...
	that is the glory of named parameters
Alan Gilbert:
	I see, the parameters has to be named "data"
Scott Ziegler:
	you can present them in any order (but after any non named positional params)
Alan Gilbert:
	so it could be "data=foo" is foo is our data dictionary, correct?
Scott Ziegler:
	yep
	it just so happens i was using data as my "name" already
	so while data=data may look like data IS data, it isn't
	the left side is a named-parameter of the method requests.post
	the right side is a local variable holding our data we are munging
Alan Gilbert:
	the concept of a named parameter is new to me
Scott Ziegler:
	it might as well be called foo, but happens to be data (as it might be a parameter itself of a calling function)
	it gets better...
	so when you define a function you can use named parameters like so...
	def foo(bar, baz='', bing=None, bongs='rule! /otto'):
	ignore the crappy emoticon
	note the first param is not named
	and is positional
	the rest all have been named by being given default values
	if I call it… >>> foo('yay')
	in the body, bar will be 'yay'
	baz will be ''
	bing will be None
	and bongs will be 'rule! /otto'
	but
	I can call it like...
	>>> foo('yooo', "I'm baz!", bongs="are dangerous kids!")
	bar will be 'yooo'
	baz will be "I'm baz!"
	bing will still be None
Alan Gilbert:
	so, baz ends up being positional because you did not call it out by name?
Scott Ziegler:
	and bongs will be "are dangerous kids!"
	yep
	it matches positionally along the order of declaration...
	but
	once you start naming them...
	you can put them out of order, like the last example...
	>>> foo('yooo', "I'm baz!", bongs="are dangerous kids!", bing="Bing!")
	note I've swapped the "order" of bongs and bing
	I could have of course just called...
	>>> foo('yooo', "I'm baz!", "Bing!", "are dangerous kids!")
	and it would just match them all up
	but
	it gets EVEN CRAZIER
Alan Gilbert:
	do tell
Scott Ziegler:
	hold onto your shit
	ok so
	the * and ** operators
	(prefix operators, technically)
	ok
	def foo(*args, **kwargs) :
	defines a function...
	that puts all positional arguments it encounters into the tuple 'args'
	and any named parameters it encounters into the dict 'kwargs'
	so if we called...
	>>> foo('yooo', "I'm baz!", "Bing!", "are dangerous kids!")
	args would be ('yooo', "I'm baz!", "Bing!", "are dangerous kids!")
	you could get the 'baz' parameter like args[1]
	but if you called it like...
	>>> foo('yooo', "I'm baz!", bongs="are dangerous kids!", bing="Bing!")
	args is ('yooo', "I'm baz!")
	and kwargs is {'bongs' : "are dangerous kids!", 'bing' : "Bing!"}
Alan Gilbert:
	woah
Scott Ziegler:
	AND...
Alan Gilbert:
	mind: blown
Scott Ziegler:
	you can use it on the calling side...
	meaning..
	lets say you had a tuple hanging around...
	called credentials...
	like >>> credentials = ('sziegler', 'awesomepassword')
	and things like login(credentials[0], credentials[1]) are such a bore...
	so...
	use * operator in reverse
	login(*credentials)
	it "unwraps the tuple, and passes it as parameters"
	likewise, ** does the same thing with dicts
	so you can pass in a dict of parameters all named up to a function by unwrapping it with **...
	named_up_function(**my_param_dict)
	you can use it to great effect with functions like zip...
	lets say you have a tuple of one thing… maybe, developers
	(jim, bill, bobberton)
	and a tuple or list of scores they got on some crap BS test
	[20, 23, 72]
	and you wanted to get a dict of developer -> score
	well
	score_dict = dict(*zip(developers, score))
Alan Gilbert:
	so…
Scott Ziegler:
	(or scores rather, I guess)
Alan Gilbert:
	post = dict({
'rejection_code': '75',
'rejection_message': "PA REJECTED."
}, **default_payload)

	is
Scott Ziegler:
	ah.. ok
Alan Gilbert:
	post = dict({
'rejection_code': '75',
'rejection_message': "PA REJECTED."
}, 
{
'bin': "001553",
'cardholder_id': "213111117",
'prescription_reference_number': "6666666",
'prescription_reference_number_qualifier': "1",
'service_provider_id': "6666666",
'service_provider_id_qualifier': "07",
'prescriber_id': "MP6666666",
'prescriber_id_qualifier': "12"
})
Scott Ziegler:
	but with all the second dict's params "unfolded"
	so they'd read...
	bin="001553", cardholder_id=…. etc
	if you were to "type them out into the call by hand"
	now,
Alan Gilbert:
	I see
Scott Ziegler:
	the dict constructor looks like dict(*args, **kwargs)
	or rather sorry
	dict(iterable, **kwargs)
	where iterable better be a list of pairs
	or an iterable of pairs
	so
	(('jim', 20), ('bill', 23), ('bobberton', 70))
	that becomes a dict with those mappings
	and any kwargs that get passed in get merged into the new dict too
	so what I was doing there was taking the rejection code dict, and making a new dict out of it while merging in the defaults
	I can then say post['foogarble'] = 'wonk' without mussing up the original dict or the default one, etc
Alan Gilbert:
	you lost me on the very last one
Scott Ziegler:
	ah well
	the whole point of me making a new dict with 

post = dict({
'rejection_code': '75',
'rejection_message': "PA REJECTED."
}, **default_payload)
	was that (lets say the first arg was called like reject_data…)
	so would be post = dict(reject_data, **default_payload)
	is that then I can modify post without molesting the pristine reject_data or default_payload
Alan Gilbert:
	I see
Scott Ziegler:
	maybe pulling the same trick in the next loop iteration so I can have a fresh dict to molest differently, to say, perform a different unit test
	but without sullying the "originals" which I can use to make a clean set of params with
Alan Gilbert:
	yup, makes sense
	post is kind of a scratchpad
Scott Ziegler:
	yar
Alan Gilbert:
	awesome, answered my question and way then some
	great stuff
	thanks!
